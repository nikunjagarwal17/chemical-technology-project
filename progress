Progress plan and presentation split

This document splits the project into three presentation parts (Part 1, Part 2, Part 3) and provides detailed notes, artifacts, required utilities, challenges, implementation status, and a technical Q&A prep to support meeting presentations.

----
Summary (what follows)
- Part 1: Design & folder-structure ideation, API surface, modular architecture, plan and milestones (present now).
- Part 2: Current codebase status — what is implemented, remaining functions, tests, demos (present in ~1 month).
- Part 3: Final product — packaged wheels, CI, documentation, polished examples, benchmarking and release (target after Part 2).

Each part below contains:
- Goals & Deliverables for the presentation
- Artifacts and utilities you should prepare (slides, demos, commands, files to point to)
- Talking points and bullet explanations (what to say) including technical terms
- Challenges encountered + current mitigations and future plans
- Anticipated cross-questions and short answers to prepare

----
PART 1 — Design, folder structure, and modular plan (present NOW)

Goals & deliverables for this meeting
- Explain the repository layout and why each folder exists.
- Walk through the modular architecture (public API, pure-Python reference, C++ core, Cython bindings, IO/specs, examples, tests).
- Present the interface contract (inputs/outputs, error modes) for main components.
- Show a demo plan (what you will demo in later parts) and timeline for the next month.

Artifacts & utilities to have ready for the meeting
- Slide deck (1–10 slides): project summary, architecture diagram, folder map, APIs, timeline, risks.
- Open the file `folder str` (already created) to show the annotated folder map in your repo.
- Simple live demo plan (no compiled extension needed): run one example with pure-Python fallback:
  - Commands (Windows cmd):

    python -m test1
    python -m test2
    python -m test3

  - These create PNGs under `examples/` and demonstrate the full run path without native builds.
- A short script to show the public API and how import chooses compiled vs pure-Python (open `pyroxa/__init__.py`).
- A one-slide timeline showing Part 2 and Part 3 milestones (deliverable dates, resources needed).

Design + modular structure to present (talking points)
- Layered design:
  1. Public API: `pyroxa.__init__` provides `Reaction`, `WellMixedReactor`, `CSTR`, `PFR`, `ReactorNetwork`, etc.
  2. Pure-Python reference: `pyroxa/purepy.py` — fully functional fallback implementing RK4 and adaptive integrators (step-doubling RK4).
  3. Performance core: `src/core.cpp` + `src/core.h` — C++ implementation for RK4 and Cash–Karp RK45 adaptive integrator.
  4. Bindings: `pyroxa/pybindings.pyx` (Cython) — exposes C++ functions to Python; `pybindings.cpp` may be generated at build-time.
  5. IO/Specs: YAML specs in `examples/` and helper `io.py` / `build_from_dict` to construct runtime objects.
  6. Packaging/CI: `pyproject.toml`, `setup.py`, and GitHub Actions + cibuildwheel to produce wheels.
- Contract and usage examples: show a small bullet mapping of inputs -> outputs for main API functions (e.g., reactor.run(time_span, dt) -> times, trajectory).

What to emphasize about design choices
- Pure-Python fallback is deliberate: ensures reproducible demos without a C toolchain, speeds early development and testing.
- C++ + Cython only used for performance-critical paths; they are optional for users but required for production-grade speed.
- YAML specs and `build_from_dict` standardize experiments and enable reproducible demos, tests, and CI.

Risks and mitigations to discuss
- Risk: Local builds are fragile across CPython/Cython/NumPy permutations (observed unresolved externals and C API mismatches).
  - Mitigation: Use CI (cibuildwheel) for building wheels across OS/versions; pin Cython in `pyproject.toml` for reproducible cythonization during isolated builds.
- Risk: Complexity of keeping pre-generated wrapper (`pybindings.cpp`) consistent with build environment.
  - Mitigation: Prefer regenerating with the build-time Cython in PEP-517 isolated builds; only commit generated wrapper if you lock toolchain.

Anticipated cross-questions and short answers (Part 1)
- Q: "Can I run the project without a C compiler?"
  - A: Yes — use the pure-Python fallback (`purepy.py`) and run the examples/tests as shown.
- Q: "Why both Python and C++?"
  - A: Rapid development and correctness in Python; performance-critical integrators in C++ for speed. Cython bridges them.
- Q: "How do you ensure reproducible builds?"
  - A: `pyproject.toml` lists build-system requires (numpy, pinned Cython), CI uses isolated environments (cibuildwheel) for consistent artifacts.

Deliverable checklist for Part 1
- Slide deck + `folder str` open during the meeting — show architecture and file map.
- Run `python -m test1` during demo to prove the pure-Python path.
- Show `pyroxa/purepy.py` snippet for RK4/adaptive integrator to explain math.

----
PART 2 — Current code, demos, remaining functions (present in ~1 month)

Goals & deliverables
- Demonstrate completed code paths: pure-Python tests, example simulations, plotting, CSV outputs.
- Show progress on C++ core and Cython bindings; present any compiled artifacts (CI-built wheels) or local build logs.
- Explain remaining functions to implement and planned approach/time estimates.

What is implemented now (summary)
- Pure-Python engine (`purepy.py`): Thermodynamics, Reaction (A <=> B), ReactionMulti, WellMixedReactor, CSTR, PFR, MultiReactor, ReactorNetwork, RK4 and adaptive integrators — tested and working locally.
- Examples + YAML specs: `examples/` contains multiple specs and scripts (`test1.py`, `test2.py`, `test3.py`) that generate plots and CSV.
- Unit tests: `tests/` contains pytest tests (8 tests) — passing locally.
- C++ core and Cython wrapper: source files present (`src/core.cpp`, `src/core.h`, `pyroxa/pybindings.pyx`), but local builds have produced environment-specific issues; CI integration exists.

Remaining tasks (explicit)
- Fix and stabilise local/native builds on Windows/CPython 3.13 (resolve C-API mismatches) or document a recommended Python toolchain for local builds.
- Implement any remaining advanced reaction kinetics and multi-reaction features (if on roadmap).
- Add more robust tests for C++/Cython path. Add microbenchmarks comparing Python vs C++ paths.
- Polish documentation and examples.

Artifacts to prepare for Part 2 presentation
- Live demo (two modes):
  1. Pure-Python demo: run `python -m test1` and show plots/results.csv.
  2. C++/Cython demo: if CI wheels available, install wheel in a clean venv and run same demo to show speed improvement.
- Benchmark slides: runtime comparisons for representative problems.
- Build logs and CI artifacts to show what failed and how we fixed it.

Anticipated cross-questions (Part 2)
- Q: "What exactly failed in local Windows builds?"
  - A: C-API symbol mismatches and unresolved externals caused by differences between Cython-generated code and CPython internals on 3.13; mitigation is pinned Cython in build-system and CI-based wheel generation.
- Q: "How much faster is the C++ core?"
  - A: Provide microbenchmark numbers (planned). Expect 3-10x improvements on stiff or vectorized problems; actual numbers depend on problem size.

----
PART 3 — Final product & release (release presentation)

Goals & deliverables
- Final release artifacts: wheels for common platforms, polished docs, user guide, extended examples and tutorials, and a small benchmark suite.
- Show CI workflow and reproduce a wheel install and demo on a clean environment.

Deliverables and acceptance criteria
- Wheels published for Windows/macOS/Linux matching target Python versions.
- Documentation pages and usage examples; quickstart working with `pip install mypackage` (or `pip install dist/wheel-file.whl`).
- Tests passing across the CI matrix; microbenchmarks added to repository.

Artifacts to prepare for final meeting
- Live install demo from wheel into a fresh venv and run an example.
- Documentation site (Sphinx or simple README pages) and quickstart section.
- Release notes and changelog describing differences, performance, and compatibility.

Anticipated cross-questions (Part 3)
- Q: "How will you maintain API stability?"
  - A: Keep pure-Python reference implementation as canonical behavior; run tests on both paths; follow semantic versioning and deprecate features with clear timelines.
- Q: "What support matrix will you offer?"
  - A: Initially target CPython 3.10–3.12 (extend to 3.13 after stabilizing C API), and provide manylinux wheels for Linux, macOS wheels (universal or per-arch), and Windows wheels produced via CI.

----
Challenges we faced, how we are solving them, and what's done so far
- Challenge: unpredictable local native builds (Cython/CPython ABI mismatch; missing NumPy headers).
  - Status: documented in `DEV.md` and `INSTALL_WINDOWS_WHEELS.txt`; mitigation: pin Cython in `pyproject.toml`, add NumPy as build-require, prefer CI builds (cibuildwheel).
- Challenge: keeping wrapper generation reproducible.
  - Status: removed committed pre-generated `.cpp` when it caused mismatches and prefer PEP-517 regeneration; option to commit generated file if tooling is locked.
- Challenge: providing both a friendly Python API and a performant core.
  - Status: implemented pure-Python reference; C++ core present; bridging code and packaging strategy created.

How the project works (technical description, for cross-question prep)
- High-level flow:
  - Users write a YAML spec or use API to create a Reaction and a Reactor object.
  - The builder (`build_from_dict`) constructs objects; reactors expose `run(time_span, dt)` producing `times, traj`.
  - Pure-Python path: `purepy.py` uses explicit RK4 or adaptive step-doubling RK4 for integration; these are straightforward explicit integrators.
  - C++ path: `src/core.cpp` implements RK4 and Cash-Karp RK45 (an embedded Runge–Kutta method with adaptive step size control). The C++ functions are wrapped via Cython and exposed as a compiled module for speed.
- Key algorithms:
  - RK4 (classical 4th-order Runge–Kutta): fixed-step, accurate for smooth problems.
  - Step-doubling RK4: a simple adaptive approach in pure Python — take one step of size dt and two of dt/2, compare to estimate local error and adapt dt.
  - Cash–Karp RK45: 5th-order embedded integrator with an error estimate used to adapt step size more robustly (used in C++ core).
- Packaging and build details (technical):
  - `pyproject.toml` declares build-system requirements so PEP-517 isolated builds can cythonize with the build-time Cython and use NumPy includes.
  - `setup.py` contains conditional cythonize logic, adds numpy.get_include() to include_dirs, and sets appropriate compiler flags for C++17 where necessary.
  - For reproducible wheels we use `cibuildwheel` in CI to build manylinux/macOS/Windows wheels in controlled environments.

Detailed Q&A prep (longer answers you can read aloud)
- Q: "Why does the pure-Python integrator use step-doubling instead of a standard RK45?"
  - A: Step-doubling is simple to implement in pure Python, gives adaptive control without third-party dependencies, and is sufficient for the moderate-size example problems used in demos; for production-grade adaptive control and stiff problems we use the C++ Cash–Karp RK45 which is more efficient and robust.
- Q: "What caused the Windows linker unresolved externals?"
  - A: Cython 3.x generated code that referenced new or unstable CPython internals on some compiler/linker variants. That plus an environment where libpython linkage flags were incorrectly applied produced unresolved symbols. The fix was to pin Cython < 3.0 for builds or let PEP-517 regenerate using the CI's internal toolchain.
- Q: "How do you handle multi-species reactions?"
  - A: `ReactionMulti` and `MultiReactor` support arbitrary species lists and reactions given as stoichiometry dicts; the code maps species names to indices and integrates an array of concentrations using vector RK4 steps.
- Q: "How will you measure and show performance improvements?"
  - A: Prepare microbenchmarks: convert a representative reaction network into MultiReactor, run for a fixed simulated time and dt, measure runtime of pure-Python vs compiled C++ path and show speedups. Record on the slides and attach CSV results.

Presentation utilities and checklist (what to prepare now)
- Slides (PowerPoint/Google Slides/Markdown) covering architecture, timeline, demo plan, and risks.
- Local demo commands for pure-Python path:

  python -m test1
  python -m test2
  python -m test3

- Files to point to in the repo during presentation:
  - `folder str` (folder map)
  - `pyroxa/__init__.py` (import fallback logic)
  - `pyroxa/purepy.py` (show RK4/adaptive implementation, Reaction API)
  - `examples/test1_spec.yaml`, `examples/test2_spec.yaml`, `examples/test3_spec.yaml` and `examples/*.png`
  - `tests/` (pytest tests) and `run_test_import.py` for a quick import check
- If you plan a recorded demo: record running `python -m test1` and show the generated PNG and `results.csv` in the recording.

Timeline & recommended immediate actions (for you to prepare Part 2 in a month)
- Next week: Stabilise remaining small feature implementations and write 2–3 additional unit tests for edge cases.
- Two weeks: Add a microbenchmark script and collect performance data on your machine and CI.
- Three weeks: Attempt a CI wheel run (or re-run CI) and capture artifacts; resolve any build errors with focused debugging (if any remain).
- One month: prepare Part 2 slides with code diffs, benchmarks, and a live wheel demo if available.

Closing notes
- The repository is intentionally designed to be usable without a native toolchain; use that advantage for Part 1 demos.
- Save CI/build logs and sample wheel artifacts; they are valuable evidence of cross-platform reproducibility to show in the Part 2/3 presentations.

If you want, I can:
- Convert this `progress` file to Markdown and create a short slide deck template.
- Generate the Part 1 slide bullets into a compact PDF or Markdown slides.
- Create a quickstart `PART1_QUICKSTART.md` with exact commands to run during your meeting.

Which follow-up should I do next?
